{"ast":null,"code":"import { Transport } from \"../transport.js\";\nimport { nextTick } from \"../globals.node.js\";\nimport { createPacketDecoderStream, createPacketEncoderStream } from \"engine.io-parser\";\n/**\n * WebTransport transport based on the built-in `WebTransport` object.\n *\n * Usage: browser, Node.js (with the `@fails-components/webtransport` package)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebTransport\n * @see https://caniuse.com/webtransport\n */\nexport class WT extends Transport {\n  get name() {\n    return \"webtransport\";\n  }\n  doOpen() {\n    try {\n      // @ts-ignore\n      this._transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n    } catch (err) {\n      return this.emitReserved(\"error\", err);\n    }\n    this._transport.closed.then(() => {\n      this.onClose();\n    }).catch(err => {\n      this.onError(\"webtransport error\", err);\n    });\n    // note: we could have used async/await, but that would require some additional polyfills\n    this._transport.ready.then(() => {\n      this._transport.createBidirectionalStream().then(stream => {\n        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);\n        const reader = stream.readable.pipeThrough(decoderStream).getReader();\n        const encoderStream = createPacketEncoderStream();\n        encoderStream.readable.pipeTo(stream.writable);\n        this._writer = encoderStream.writable.getWriter();\n        const read = () => {\n          reader.read().then(({\n            done,\n            value\n          }) => {\n            if (done) {\n              return;\n            }\n            this.onPacket(value);\n            read();\n          }).catch(err => {});\n        };\n        read();\n        const packet = {\n          type: \"open\"\n        };\n        if (this.query.sid) {\n          packet.data = `{\"sid\":\"${this.query.sid}\"}`;\n        }\n        this._writer.write(packet).then(() => this.onOpen());\n      });\n    });\n  }\n  write(packets) {\n    this.writable = false;\n    for (let i = 0; i < packets.length; i++) {\n      const packet = packets[i];\n      const lastPacket = i === packets.length - 1;\n      this._writer.write(packet).then(() => {\n        if (lastPacket) {\n          nextTick(() => {\n            this.writable = true;\n            this.emitReserved(\"drain\");\n          }, this.setTimeoutFn);\n        }\n      });\n    }\n  }\n  doClose() {\n    var _a;\n    (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();\n  }\n}","map":null,"metadata":{},"sourceType":"module"}